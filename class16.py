# and(&) : 동시에 true여야 true가 된다.
# - 둘중에 하나라도 false면 false가 나온다.
# 1: ture / 0 :false
from sre_constants import AT_NON_BOUNDARY


print(1&1)

# or(|) : 둘중에 하나만 true이면 true가 된다.
# - 둘다 false여야 false가 된다.
print(1|1)

# xor(^) : 두값이 형태가 서로 달라야만 true야 됩니다.
# - true true (X) False false (X)
# - true false (O) false ture (O)

print(1^0)

# binary : 이진수
# 2진수 숫자를 문자열로 바꾸는 방법
# bin()

bin_a = 0b00111100
bin_b = 0b00001101
# &     0b00001100
# |     0b00111101
# ^     0b00110001
print(bin(bin_a&bin_b))
print(bin(bin_a|bin_b))
print(bin(bin_a^bin_b))


key = [[1,1,1,1,0,1,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0],
   [0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1],
   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
   [1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1],
   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
   [0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1],
   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
   [0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,1,1,1],
   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
   [0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0],
   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]

painting = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1],
      [1,1,1,1,0,1,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1],
      [1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,0,1,1,1,1,0],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0]]



# for e in range(len(key)):
#   print(e)

# for a in range(len(painting)):
#   print(a)



# 비트 연산을 해주는 함수를 한번 보기
# 입력값: key, painting



def e(a,b):
  and_a = []
  or_a = []
  xor_a =[]
  for i in range(len(a)):
    #  빈 리스트 => 행데이터
    d = []
    o = []
    x = []
    for j in range(len(a[i])):
      # 이차원리스트의 값 뽑기 리스트변수[행인덱스][열인덱스]
      # 동일안 위치의 값을 비트 연산해줄겁니다.
      jujang = a[i][j] #key값
      juujang = b[i][j] #painting값
      #print(jujang,juujang)
      #print(jujang&juujang,'and')
      #print(jujang|juujang,'or')
      #print(jujang^juujang,'xor')
      d.append(jujang&juujang)
      o.append(jujang|juujang)
      x.append(jujang^juujang)
    #print(d)
    or_a.append(o)
    xor_a.append(x)
    and_a.append(d)
  print(and_a)
  # print('-----까지 and','완')
  # print(or_a)
  # print('-----까지 or',"벽")
  # print(xor_a)
  # print('-----까지 xor',"하")
  # print('다')

  # and_a 반복돌려서 0이면 "  ", 1이면 "//"
  #줄바꿈 문자 \n
  print("===and====")
  for ii in range(len(and_a)):
    for jj in range(len(and_a[ii])):

      if and_a[ii][jj] == 0:
        print("  ",end = "")
      elif and_a[ii][jj] == 1:
        print("//",end = "")
    print("\n")

  print("===or====")
  for ii in range(len(or_a)):
    for jj in range(len(or_a[ii])):

      if or_a[ii][jj] == 0:
        print("  ",end = "")
      elif or_a[ii][jj] == 1:
        print("//",end = "")
    print("\n")

  print("===xor====")
  for ii in range(len(xor_a)):
    for jj in range(len(xor_a[ii])):

      if xor_a[ii][jj] == 0:
        print("  ",end = "")
      elif xor_a[ii][jj] == 1:
        print("//",end = "")
    print("\n")


e(key,painting)


52.132
5.291

















